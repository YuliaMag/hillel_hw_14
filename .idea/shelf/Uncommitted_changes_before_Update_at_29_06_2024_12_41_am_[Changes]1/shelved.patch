Index: tests/test_string_representation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pytest\r\n\r\nfrom staff import pxl\r\n\r\n\r\n@pytest.mark.skip(reason=\"failing for unknown reason\")\r\ndef test_string_representation():\r\n    pxl.Pixel = pxl.Pixel(100, 150, 200)\r\n    assert str(pxl.Pixel) == \"pxl.Pixel(100, 150, 200)\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/test_string_representation.py b/tests/test_string_representation.py
--- a/tests/test_string_representation.py	
+++ b/tests/test_string_representation.py	
@@ -3,7 +3,22 @@
 from staff import pxl
 
 
-@pytest.mark.skip(reason="failing for unknown reason")
-def test_string_representation():
-    pxl.Pixel = pxl.Pixel(100, 150, 200)
-    assert str(pxl.Pixel) == "pxl.Pixel(100, 150, 200)"
+@pytest.mark.skip(reason="to practice skip")
+def test_str_method():
+    pixel1 = pxl.Pixel(255, 128, 64)
+    assert str(pixel1) == "Pixel:\t\nRed: 255, Green: 128, Blue: 64"
+
+
+def test_repr_method():
+    pixel2 = pxl.Pixel(255, 128, 64)
+    assert repr(pixel2) == "Pixel(255, 128, 64)"
+
+
+
+
+# @pytest.mark.skip(reason="failing for unknown reason")
+# def test_string_representation():
+#     pxl.Pixel = pxl.Pixel(100, 150, 200)
+#
+#     assert str(pxl.Pixel) == "pxl.Pixel(100, 150, 200)"
+#     assert repr(pxl.Pixel) == "pxl.Pixel(100, 150, 200)"
Index: staff/pxl.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class Pixel:\r\n\r\n    # The constructor that takes three arguments: red, green, and blue\r\n    def __init__(self, red, green, blue):\r\n        if not 0 <= red <= 255 or not 0 <= green <= 255 or not 0 <= blue <= 255:\r\n            raise ValueError(\"ValueError: pixel components must be in range [0, 255]!\")\r\n        self._red = red\r\n        self._green = green\r\n        self._blue = blue\r\n\r\n    # Implemented property that allows read-only access to the private component field\r\n    @property\r\n    def red(self):\r\n        return self._red\r\n\r\n    # Implemented property that allows read-only access to the private component field\r\n    @property\r\n    def green(self):\r\n        return self._green\r\n\r\n    # Implemented property that allows read-only access to the private component field\r\n    @property\r\n    def blue(self):\r\n        return self._blue\r\n\r\n    # Adding two pixels results in a new Pixel object with components equal to the sum of the corresponding components\r\n    def __add__(self, other):\r\n        new_red = min(255, max(0, self.red + other.red))\r\n        new_green = min(255, max(0, self.green + other.green))\r\n        new_blue = min(255, max(0, self.blue + other.blue))\r\n        return Pixel(new_red, new_green, new_blue)\r\n\r\n    # Subtracting two pixels results in a new Pixel object with components equal to the difference of the\r\n    # corresponding components\r\n    def __sub__(self, other):\r\n        new_red = min(255, max(0, self.red - other.red))\r\n        new_green = min(255, max(0, self.green - other.green))\r\n        new_blue = min(255, max(0, self.blue - other.blue))\r\n        return Pixel(new_red, new_green, new_blue)\r\n\r\n    # Multiplying two pixels results in a new Pixel object with components equal to the multiplied of the\r\n    # corresponding components. Errors handled\r\n    def __mul__(self, other):\r\n        if isinstance(other, Pixel):\r\n            new_red = min(255, max(0, int(self.red * other.red / 255)))\r\n            new_green = min(255, max(0, int(self.green * other.green / 255)))\r\n            new_blue = min(255, max(0, int(self.blue * other.blue / 255)))\r\n            return Pixel(new_red, new_green, new_blue)\r\n        elif isinstance(other, (int, float)):\r\n            if other <= 0:\r\n                raise ValueError(\"ValueError: multiplier must be greater than zero!\")\r\n            new_red = min(255, max(0, int(self.red * other)))\r\n            new_green = min(255, max(0, int(self.green * other)))\r\n            new_blue = min(255, max(0, int(self.blue * other)))\r\n            return Pixel(new_red, new_green, new_blue)\r\n        else:\r\n            raise TypeError(\"TypeError: multiplier must be an integer or float!\")\r\n\r\n    def __rmul__(self, other):\r\n        return self.__mul__(other)\r\n\r\n    # Dividing two pixels results in a new Pixel object with components equal to the dividing of the\r\n    # corresponding components. Errors handled\r\n    def __truediv__(self, other):\r\n        if isinstance(other, Pixel):\r\n            new_red = min(255, max(0, int(self.red / other.red)))\r\n            new_green = min(255, max(0, int(self.green / other.green)))\r\n            new_blue = min(255, max(0, int(self.blue / other.blue)))\r\n            return Pixel(new_red, new_green, new_blue)\r\n        elif isinstance(other, (int, float)):\r\n            if other <= 0:\r\n                raise ValueError(\"ValueError: divider must be greater than zero!\")\r\n            new_red = min(255, max(0, int(self.red / other)))\r\n            new_green = min(255, max(0, int(self.green / other)))\r\n            new_blue = min(255, max(0, int(self.blue / other)))\r\n            return Pixel(new_red, new_green, new_blue)\r\n        else:\r\n            raise TypeError(\"TypeError: divider must be an integer or float!\")\r\n\r\n    # Two Pixel objects are considered equal if their corresponding components are equal\r\n    def __eq__(self, other):\r\n        if isinstance(other, Pixel):\r\n            return (self.red, self.green, self.blue) == (other.red, other.green, other.blue)\r\n        return False\r\n\r\n    # def __str__(self):\r\n    #     return f\"Pixel:\\t\\nRed: {self.red}, Green: {self.green}, Blue: {self.blue}\"\r\n\r\n    # def __repr__(self):\r\n    #     return f\"Pixel({self.red}, {self.green}, {self.blue})\"\r\n\r\n    # Frankly.. I don't know. I'm trying to make them work simultaneously, but they don't want to\r\n    def __str__(self):\r\n        if hasattr(self, \"__repr__\"):\r\n            # return self.__repr__()\r\n            return f\"Pixel({self.red}, {self.green}, {self.blue})\"\r\n        else:\r\n            return f\"Pixel:\\t\\nRed: {self.red}, Green: {self.green}, Blue: {self.blue}\"\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/staff/pxl.py b/staff/pxl.py
--- a/staff/pxl.py	
+++ b/staff/pxl.py	
@@ -83,17 +83,16 @@
             return (self.red, self.green, self.blue) == (other.red, other.green, other.blue)
         return False
 
-    # def __str__(self):
-    #     return f"Pixel:\t\nRed: {self.red}, Green: {self.green}, Blue: {self.blue}"
-
-    # def __repr__(self):
-    #     return f"Pixel({self.red}, {self.green}, {self.blue})"
-
-    # Frankly.. I don't know. I'm trying to make them work simultaneously, but they don't want to
     def __str__(self):
-        if hasattr(self, "__repr__"):
-            # return self.__repr__()
-            return f"Pixel({self.red}, {self.green}, {self.blue})"
-        else:
-            return f"Pixel:\t\nRed: {self.red}, Green: {self.green}, Blue: {self.blue}"
+        return f"Pixel:\t\nRed: {self.red}, Green: {self.green}, Blue: {self.blue}"
 
+    def __repr__(self):
+        return f"Pixel({self.red}, {self.green}, {self.blue})"
+
+    # def __str__(self):
+    #     if hasattr(self, "__repr__"):
+    #         # return self.__repr__()
+    #         return f"Pixel({self.red}, {self.green}, {self.blue})"
+    #     else:
+    #         return f"Pixel:\t\nRed: {self.red}, Green: {self.green}, Blue: {self.blue}"
+
